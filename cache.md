
```yaml
- uses: actions/setup-node@v4
  with:
    node-version: 20
    cache: npm
```

この

```
cache: npm
```

は
**依存パッケージのダウンロード結果を保存して、次回CIを高速化する機能** です。
（in **GitHub Actions**）

---

# 何が遅いのか

CIが遅くなる最大の原因はここ

```
npm ci
↓
数百MBダウンロード
↓
毎回ゼロからインストール
```

毎回これをやると 1〜3分 消えます。

---

# cache: npm がやってること

初回実行

```
npmパッケージをダウンロード
↓
~/.npm を保存（キャッシュ）
```

2回目以降

```
キャッシュ復元
↓
npm ci がローカルコピーから展開
↓
ほぼ一瞬
```

---

# 重要ポイント

キャッシュされるのは **node_modules ではない**

```
node_modules ❌
npmのダウンロードキャッシュ ⭕
(~/.npm)
```

だから安全です

* OS差異で壊れない
* lockfileが変わると自動無効化

---

# どうやって無効化判定してる？

`package-lock.json` のハッシュを見ています

つまり

| 状態         | 動作       |
| ---------- | -------- |
| lockfile同じ | キャッシュ再利用 |
| 依存追加       | 再インストール  |
| バージョン変更    | 再インストール  |

👉 常に再現性は保たれる

---

# 実際の速度差

| 状態      | 所要時間    |
| ------- | ------- |
| キャッシュなし | 60〜180秒 |
| キャッシュあり | 5〜15秒   |

体感めちゃ変わります

---

# よくある誤解

### 「node_modules が保存される？」

されません
あれを保存すると壊れます（OS依存）

---

# まとめ

`cache: npm` =

> npmのダウンロード済みパッケージを保存して
> 次回CIのインストールを爆速にする安全なキャッシュ

CIではほぼ必須設定です 👍

---
---
# cache:にはフォルダのパスを設定するの？

> `cache:` に書くのは「フォルダのパス」ではありません

これは **GitHub Actions** の
**actions/setup-node 専用オプション** で、
「どのパッケージマネージャのキャッシュ方式を使うか」を指定しています。

---

# cache の正体

```yaml
- uses: actions/setup-node@v4
  with:
    node-version: 20
    cache: npm
```

ここで指定できる値は

| 値    | 意味                |
| ---- | ----------------- |
| npm  | ~/.npm をキャッシュ     |
| yarn | yarn cache をキャッシュ |
| pnpm | pnpm store をキャッシュ |

👉 **ツール名を指定するだけ**

内部で自動的に正しいディレクトリを特定します。

---

# じゃあパスを指定したい場合は？

それは別の仕組みを使います

```
actions/cache
```

例：

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.cache/mytool
    key: mytool-${{ hashFiles('**/lockfile') }}
```

これは「任意フォルダのキャッシュ」

---

# なぜ setup-node はパス不要？

Node のパッケージマネージャは
OSごとにキャッシュ場所が違うからです

| OS      | npm cache   |
| ------- | ----------- |
| Linux   | ~/.npm      |
| macOS   | ~/.npm      |
| Windows | AppData/... |

それを自動吸収してくれます

---

# よくある勘違い

### ❌ node_modules をキャッシュする設定

```yaml
path: node_modules
```

→ 壊れやすい（非推奨）

### ⭕ setup-node の cache

再現性を壊さず高速化

---

# まとめ

| 設定              | 役割                   |
| --------------- | -------------------- |
| `cache: npm`    | パッケージマネージャ専用の安全キャッシュ |
| `actions/cache` | 任意フォルダを保存            |

つまり

> cache は「種類指定」
> path は「場所指定」

---
---

# このキャッシュはどこに保存されるの？ 毎回コンテナを立ち上げるとキャッシュ消えちゃいそうだけど

確かに runner（ubuntu）は **毎回まっさらなVM** なので
ローカルディスクに保存したら消えます。

でも `cache: npm` はそこに保存していません。

---

# 結論

> キャッシュは runner の中ではなく
> **GitHub側のストレージに保存されます**

（in **GitHub Actions**）

つまり

```
VM(毎回破棄)
   ↑
   ↓ ダウンロード/アップロード
GitHub Cache Storage(永続)
```

---

# 実際の流れ

## 1回目のCI

```
runner起動（空）
npm ci（ダウンロード）
↓
~/.npm をGitHubへアップロード
```

## 2回目以降

```
runner起動（空）
↓
GitHubからキャッシュを復元
↓
npm ci（展開だけ）
```

だからコンテナでもVMでも問題ありません。

---

# どこに紐づくの？

キャッシュは次の単位で管理されます

* リポジトリ
* ブランチ（キー）
* lockfileのハッシュ

つまり

```
同じ依存関係のときだけ再利用
```

---

# いつ消える？

GitHubの仕様

| 条件         | 削除        |
| ---------- | --------- |
| 7日間未使用     | 削除        |
| サイズ上限超え    | 古い順削除     |
| lockfile変更 | 新規キャッシュ作成 |

---

# 重要なイメージ

ローカルPCのキャッシュではなく

> GitHubが持つCDNキャッシュを使ってる感覚

---

# よくある誤解

### 「コンテナだからキャッシュ無意味？」

→ 意味ある
毎回ダウンロードしないのが目的

---

# まとめ

* runnerの中 → 毎回消える
* cache → GitHubの外部保存
* 次回 → 復元される

だから CI が爆速になります 👍

---

# キャッシュの有効期限は？
GitHub Actions のキャッシュ（`cache: npm` や `actions/cache`）の有効期限は次のルールです
（in **GitHub Actions**）

---

# 有効期限

> **最後に使われてから 7日間**

7日間そのキャッシュが一度も復元されなければ
自動的に削除されます。

---

# イメージ

```
Day 0  作成
Day 3  CIで使用 → 延命（ここから7日）
Day 8  使用なし → 削除
```

つまり

> 使い続ける限り半永久的に残る
> 使われなくなったら7日で消える

---

# ただし例外（重要）

## 1. 上限容量に達した

GitHubはリポジトリごとにキャッシュ容量制限があります
（約 10GB）

超えると

> 古いキャッシュから削除（LRU）

---

## 2. lockfile が変わった

```
package-lock.json
pnpm-lock.yaml
yarn.lock
```

が変わるとキーが変わるので

> 新キャッシュ作成（旧は7日後削除）

---

# まとめ

| 条件   | 削除タイミング     |
| ---- | ----------- |
| 未使用  | 7日          |
| 容量超過 | 古い順         |
| 依存変更 | 新規作成＋旧は自然消滅 |

---

# 実務的な理解

CIが毎日回るプロジェクトなら

> ほぼ永続キャッシュ

週1以下のリポジトリだと

> 毎回再ダウンロードになることがある

---

---
# lockfileの内容を監視しているの？
はい 👍
**実質的に “lockfile を監視している” 挙動** になります。

（in **GitHub Actions**）

ただし正確には

> 中身を常時監視しているのではなく
> **ハッシュ値をキーにして別キャッシュとして扱っている**
> です。

---

# 仕組み

`setup-node` の

```yaml
cache: npm
```

は内部でこんなキーを自動生成します

```
OS + node-version + lockfileのハッシュ
```

イメージ：

```
linux-node20-<hash(package-lock.json)>
```

---

# 動作

## 初回

```
lockfile A
↓
キャッシュ作成
```

## 依存変更

```
lockfile B（内容変化）
↓
ハッシュ変わる
↓
別キャッシュ扱い（再インストール）
```

つまり

> 「lockfileが同じ＝完全同一環境」
> のときだけ再利用

---

# だから安全

もしキャッシュが
`node_modules` 基準だったら…

```
package.json変えたのに古い依存が残る
→ 地獄
```

これを防ぐために lockfile を基準にしています。

---

# 実際のログ

CIログに出ます

```
Cache restored from key: linux-node20-abcdef12345
```

lockfile変わると

```
Cache not found
```

---

# まとめ

| 状態         | 挙動      |
| ---------- | ------- |
| lockfile同じ | キャッシュ復元 |
| 1文字でも変更    | 新キャッシュ  |
| 古いキャッシュ    | 7日後削除   |

---

つまり

> GitHubは lockfile を「環境の指紋」として扱ってる

これがCIの再現性のキモです 👍

